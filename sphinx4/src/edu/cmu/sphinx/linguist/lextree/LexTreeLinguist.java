/*
 * Copyright 1999-2002 Carnegie Mellon University.  
 * Portions Copyright 2002 Sun Microsystems, Inc.  
 * Portions Copyright 2002 Mitsubishi Electric Research Laboratories.
 * All Rights Reserved.  Use is subject to license terms.
 * 
 * See the file "license.terms" for information on usage and
 * redistribution of this file, and for a DISCLAIMER OF ALL 
 * WARRANTIES.
 *
 */

package edu.cmu.sphinx.linguist.lextree;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.logging.Logger;

import edu.cmu.sphinx.linguist.HMMSearchState;
import edu.cmu.sphinx.linguist.Linguist;
import edu.cmu.sphinx.linguist.SearchGraph;
import edu.cmu.sphinx.linguist.SearchState;
import edu.cmu.sphinx.linguist.SearchStateArc;
import edu.cmu.sphinx.linguist.UnitSearchState;
import edu.cmu.sphinx.linguist.WordSearchState;
import edu.cmu.sphinx.linguist.WordSequence;
import edu.cmu.sphinx.linguist.acoustic.AcousticModel;
import edu.cmu.sphinx.linguist.acoustic.HMM;
import edu.cmu.sphinx.linguist.acoustic.HMMState;
import edu.cmu.sphinx.linguist.acoustic.HMMStateArc;
import edu.cmu.sphinx.linguist.acoustic.Unit;
import edu.cmu.sphinx.linguist.acoustic.UnitManager;
import edu.cmu.sphinx.linguist.dictionary.Dictionary;
import edu.cmu.sphinx.linguist.dictionary.Pronunciation;
import edu.cmu.sphinx.linguist.dictionary.Word;
import edu.cmu.sphinx.linguist.language.ngram.LanguageModel;
import edu.cmu.sphinx.linguist.util.HMMPool;
import edu.cmu.sphinx.util.LogMath;
import edu.cmu.sphinx.util.Timer;
import edu.cmu.sphinx.util.props.PropertyException;
import edu.cmu.sphinx.util.props.PropertySheet;
import edu.cmu.sphinx.util.props.PropertyType;
import edu.cmu.sphinx.util.props.Registry;

/**
 * A linguist that can represent large vocabularies efficiently. This class
 * implements the Linguist interface. The main role of any linguist is to
 * represent the search space for the decoder. The initial state in the search
 * space can be retrieved by a SearchManager via a call to <code> getInitialSearchState</code>.
 * This method returns a SearchState. Successor states can be retrieved via
 * calls to <code>SearchState.getSuccessors().</code>. There are a number of
 * search state subinterfaces that are used to indicate different types of
 * states in the search space:
 * 
 * <ul>
 * <li><b>WordSearchState </b>- represents a word in the search space.
 * <li><b>UnitSearchState </b>- represents a unit in the search space
 * <li><b>HMMSearchState </b> represents an HMM state in the search space
 * </ul>
 * 
 * A linguist has a great deal of latitude about the order in which it returns
 * states. For instance a 'flat' linguist may return a WordState at the
 * beginning of a word, while a 'tree' linguist may return WordStates at the
 * ending of a word. Likewise, a linguist may omit certain state types
 * completely (such as a unit state). Some Search Managers may want to know a
 * priori the order in which states will be generated by the linguist. The
 * method <code>getSearchStateOrder</code> can be used to retrieve the order
 * of state returned by the linguist.
 * 
 * <p>
 * Depending on the vocabulary size and topology, the search space represented
 * by the linguist may include a very large number of states. Some linguists
 * will generate the search states dynamically, that is, the object
 * representing a particular state in the search space is not created until it
 * is needed by the SearchManager. SearchManagers often need to be able to
 * determine if a particular state has been entered before by comparing states.
 * Because SearchStates may be generated dynamically, the <code>SearchState.equals()</code>
 * call (as opposed to the reference equals '==' method) should be used to
 * determine if states are equal. The states returned by the linguist will
 * generally provide very efficient implementations of <code>equals</code>
 * and <code>hashCode</code>. This will allow a SearchManager to maintain
 * collections of states in HashMaps efficiently.
 * 
 * 
 * <p>
 * <b>LexTeeLinguist Characteristics </b>
 * 
 * Some characteristics of this linguist:
 * <ul>
 * <li><b>Dynamic </b>- the linguist generates search states on the fly,
 * greatly reducing the required memory footprint
 * <li><b>tree topology </b> this linguist represents the search space as an
 * inverted tree. Units near the roots of word are shared among many different
 * words. These reduces the amount of states that need to be considered during
 * the search.
 * <li><b>HMM sharing </b>- because of state tying in the acoustic models, it
 * is often the case that triphone units that differ in the right context
 * actually are represented by the same HMM. This linguist recognizes this case
 * and will use a single state to represent the HMM instead of two states. This
 * can greatly reduce the number of states generated by the linguist.
 * <li><b>Small-footprint </b>- this linguist uses a few other techniques to
 * reduce the overall footprint of the search space. One technique that is
 * particularly helpful is to share the end word units (where the largest
 * fanout of states occurs) across all of the words. For a 60K word vocabulary,
 * these can result in a reduction in tree nodes of about 2 million to around
 * 3,000.
 * <li><b>Quick loading </b>- this linguist can compile the search space very
 * quickly. A 60K word vocabulary can be made ready in less than 10 seconds.
 * </ul>
 * 
 * This linguist is not a general purpose linguist. It does impose some
 * constraints:
 * 
 * <ul>
 * <li><b>unit size </b>- this linguist will units that are no larger than
 * triphones.
 * <li><b>n-gram grammars </b>- this linguist will generate the search space
 * directly from the N-Gram language model. The vocabulary supported is the
 * intersection of the words found in the language model and the words that
 * exist in the Dictionary. It is assumed that all sequences of words in the
 * vocabulary are valid. This linguist doesn't support arbitrary grammars.
 * </ul>
 * 
 * <p>
 * <b>Design Notes </b> The following are some notes describing the design of
 * this linguist. They may be helpful to those who want to understand how this
 * linguist works but are not necessary if you are only interested in using
 * this linguist.
 * 
 * 
 * <p>
 * <b>Search Space Representation </b> It has been shown that representing the
 * search space as a tree can greatly reduce the number of active states in a
 * search since the units at the beginnings of words can be shared across
 * multiple words. For example, with a large vocabulary (60K words), at the end
 * of a word, with a flat representation, we have to provide transitions to the
 * initial state of each possible word. That is 60K transitions. In a tree
 * based system we need to only provide transitions to each initial phone
 * (within its context). That is about 1600 transitions. This is a substantial
 * reduction. Conceptually, this tree consists of a node for each possible
 * initial unit. Each node can have an arbitrary number of children which can
 * be either unit nodes or word nodes.
 * 
 * <p>
 * This linguist uses the HMMTree class to build and represent the tree. The
 * HMMTree is given the dictionary and language model and builds the lex tree.
 * Instead of representing the nodes in the tree as phonemes and words as is
 * typically done, the HMMTree represents the tree as HMMs and words. The HMM
 * is essentially a unit within its context. This is typically a triphone
 * (although for some units (such as SIL) it is a simple phone. Representing
 * the nodes as HMM instead of nodes yields a much larger tree, but also has
 * some advantages:
 * 
 * <ul>
 * <li>Because of state-tying in the acoustic models, many distinct triphones
 * actually share an HMM. Representing the nodes as HMMs allows these shared
 * HMMs to be represented in the tree only once instead of many times if we
 * representing states as phones or triphones. This leads to a reduction in the
 * actual number of states that are considered during a search. Experiments
 * have shown that this can reduce the required beam by a factor of 2 or 3.
 * <li>By representing the nodes as HMM, we avoid having to lookup the HMM for
 * a particular triphone during the search. This is a modest savings.
 * </ul>
 * 
 * There are some disadvantages in representing the tree with HMMs:
 * 
 * <ul>
 * <li><b>size </b> since HMMs represent units in their context, we have many
 * more copies of each node. For instance, instead of having a single unit
 * representing the initial 'd' in the word 'dog' we would have about 40 HMMs,
 * one for each possible left context.
 * <li><b>speed </b> building the much larger HMM tree can take much more
 * time, since many more nodes are needed to represent the tree.
 * <li><b>complexity </b> representing the tree with HMMs is more complex.
 * There are multiple entry points for each word/unit that have to be dealt
 * with.
 * </ul>
 * 
 * Luckily the size and speed issues can be mitigated (by adding a bit more
 * complexity of course). The bulk of the nodes in the HMM tree are the word
 * ending nodes. There is a word ending node for each possible right context.
 * To reduce space, all of the word ending nodes are replaced by a single
 * EndNode. During the search, the actual hmm nodes for a particular EndNode
 * are generated on request. These sets of hmm nodes can be shared among
 * different word endings, and therefore are cached. The effect of using this
 * EndNode optimization is to reduce the space required by the tree by about
 * 300mb and the time required to generate the tree from about 60 seconds to
 * about 6 seconds.
 * 
 *  
 */
public class LexTreeLinguist implements Linguist {
    /**
     * A sphinx property used to define the grammar to use when building the
     * search graph
     */
    public final static String PROP_GRAMMAR = "grammar";
    /**
     * A sphinx property used to define the acoustic model to use when building
     * the search graph
     */
    public final static String PROP_ACOUSTIC_MODEL = "acousticModel";

    /**
     * A sphinx property used to define the unit manager to use 
     * when building the search graph
     */
    public final static String PROP_UNIT_MANAGER = "unitManager";

    /**
     * Sphinx property that defines the name of the logmath to be used by this
     * search manager.
     */
    public final static String PROP_LOG_MATH = "logMath";
    /**
     * Sphinx property used to determine whether or not the gstates are dumped. *
     * A sphinx property that determines whether or not full word histories are
     * used to determine when two states are equal.
     */
    public final static String PROP_FULL_WORD_HISTORIES = "fullWordHistories";

    /**
     * The default value for PROP_FULL_WORD_HISTORIES
     */
    public final static boolean PROP_FULL_WORD_HISTORIES_DEFAULT = true;

    /**
     * A sphinx property for the language model to be used by this grammar
     */
    public final static String PROP_LANGUAGE_MODEL = "languageModel";

    /**
     * Property that defines the dictionary to use for this grammar
     */
    public final static String PROP_DICTIONARY = "dictionary";

    /**
     * A sphinx property that defines the size of the arc cache (zero
     * to disable the cache).
     */
    public final static String PROP_CACHE_SIZE = "cacheSize";

    /**
     * Property that defines the dictionary to use for this grammar
     */
    public final static int PROP_CACHE_SIZE_DEFAULT = 0;

    // just for detailed debugging
    private final static boolean tracing = false;
    private final static SearchStateArc[] EMPTY_ARC = new SearchStateArc[0];

    // ----------------------------------
    // Subcomponents that are configured
    // by the property sheet
    // -----------------------------------
    private LanguageModel languageModel;
    private AcousticModel acousticModel;
    private LogMath logMath;
    private Dictionary dictionary;
    private UnitManager unitManager;

    // ------------------------------------
    // Data that is configured by the
    // property sheet
    // ------------------------------------
    private String name;
    private Logger logger;
    private boolean fullWordHistories = true;
    private boolean addFillerWords = false;
    private boolean generateUnitStates = false;
    private boolean wantUnigramSmear = true;
    private float unigramSmearWeight = 1.0f;
    private float unigramSmearOffset = .0f;
    private boolean cacheEnabled = false;
    private int maxArcCacheSize = 0;

    private float languageWeight;
    private float logWordInsertionProbability;
    private float logUnitInsertionProbability;
    private float logFillerInsertionProbability;
    private float logSilenceInsertionProbability;
    private float logOne;

    // ------------------------------------
    // Data used for building and maintaining
    // the search graph
    // -------------------------------------
    private Word sentenceEndWord;
    private Word[] sentenceStartWordArray;
    private SearchGraph searchGraph;
    private HMMPool hmmPool;
    private HMMTree hmmTree;
    private ArcCache arcCache = new ArcCache();

    private int cacheTrys;
    private int cacheHits;

    /*
     * (non-Javadoc)
     * 
     * @see edu.cmu.sphinx.util.props.Configurable#register(java.lang.String,
     *      edu.cmu.sphinx.util.props.Registry)
     */
    public void register(String name, Registry registry)
            throws PropertyException {
        this.name = name;
        
        registry.register(PROP_ACOUSTIC_MODEL, PropertyType.COMPONENT);
        registry.register(PROP_LOG_MATH, PropertyType.COMPONENT);
        registry.register(PROP_LANGUAGE_MODEL, PropertyType.COMPONENT);
        registry.register(PROP_DICTIONARY, PropertyType.COMPONENT);
        
        registry.register(PROP_FULL_WORD_HISTORIES, PropertyType.BOOLEAN);
        registry.register(PROP_WANT_UNIGRAM_SMEAR, PropertyType.BOOLEAN);
        registry.register(PROP_WORD_INSERTION_PROBABILITY, PropertyType.DOUBLE);
        registry.register(PROP_SILENCE_INSERTION_PROBABILITY,
                PropertyType.DOUBLE);
        registry.register(PROP_FILLER_INSERTION_PROBABILITY,
                PropertyType.DOUBLE);
        registry.register(PROP_UNIT_INSERTION_PROBABILITY, PropertyType.DOUBLE);
        registry.register(PROP_LANGUAGE_WEIGHT, PropertyType.FLOAT);
        registry.register(PROP_ADD_FILLER_WORDS, PropertyType.BOOLEAN);
        registry.register(PROP_GENERATE_UNIT_STATES, PropertyType.BOOLEAN);
        registry.register(PROP_UNIGRAM_SMEAR_WEIGHT, PropertyType.FLOAT);
        registry.register(PROP_CACHE_SIZE, PropertyType.INT);
        registry.register(PROP_UNIT_MANAGER, PropertyType.COMPONENT);
    }

    /*
     * (non-Javadoc)
     * 
     * @see edu.cmu.sphinx.util.props.Configurable#newProperties(edu.cmu.sphinx.util.props.PropertySheet)
     */
    public void newProperties(PropertySheet ps) throws PropertyException {
        logger = ps.getLogger();
        acousticModel = (AcousticModel) ps.getComponent(PROP_ACOUSTIC_MODEL,
                AcousticModel.class);
        logMath = (LogMath) ps.getComponent(PROP_LOG_MATH, LogMath.class);
        unitManager = (UnitManager) ps.getComponent(PROP_UNIT_MANAGER,
                UnitManager.class);
        languageModel = (LanguageModel) ps.getComponent(PROP_LANGUAGE_MODEL,
                LanguageModel.class);
        dictionary = (Dictionary) ps.getComponent(PROP_DICTIONARY,
                Dictionary.class);
        
        fullWordHistories = ps.getBoolean(PROP_FULL_WORD_HISTORIES,
                PROP_FULL_WORD_HISTORIES_DEFAULT);
        wantUnigramSmear = ps.getBoolean(PROP_WANT_UNIGRAM_SMEAR,
                PROP_WANT_UNIGRAM_SMEAR_DEFAULT);
        logWordInsertionProbability = logMath.linearToLog(ps.getDouble(
                PROP_WORD_INSERTION_PROBABILITY,
                PROP_WORD_INSERTION_PROBABILITY_DEFAULT));
        logSilenceInsertionProbability = logMath.linearToLog(ps.getDouble(
                PROP_SILENCE_INSERTION_PROBABILITY,
                PROP_SILENCE_INSERTION_PROBABILITY_DEFAULT));
        logFillerInsertionProbability = logMath.linearToLog(ps.getDouble(
                PROP_FILLER_INSERTION_PROBABILITY,
                PROP_FILLER_INSERTION_PROBABILITY_DEFAULT));
        logUnitInsertionProbability = logMath.linearToLog(ps.getDouble(
                PROP_UNIT_INSERTION_PROBABILITY,
                PROP_UNIT_INSERTION_PROBABILITY_DEFAULT));
        languageWeight = ps.getFloat(PROP_LANGUAGE_WEIGHT,
                PROP_LANGUAGE_WEIGHT_DEFAULT);
        addFillerWords = (ps.getBoolean(PROP_ADD_FILLER_WORDS,
                PROP_ADD_FILLER_WORDS_DEFAULT));
        generateUnitStates = (ps.getBoolean(PROP_GENERATE_UNIT_STATES,
                PROP_GENERATE_UNIT_STATES_DEFAULT));
        unigramSmearWeight = ps.getFloat(PROP_UNIGRAM_SMEAR_WEIGHT,
                PROP_UNIGRAM_SMEAR_WEIGHT_DEFAULT);
        int newMaxArcCacheSize = ps.getInt(PROP_CACHE_SIZE,
                PROP_CACHE_SIZE_DEFAULT);
        
        // if the new size of the arc cache is less than before
        // just clear out the cache, since we can easily grow it
        // but not easily shrink it.
        if (newMaxArcCacheSize < maxArcCacheSize) {
            arcCache = new ArcCache();
        }
        maxArcCacheSize = newMaxArcCacheSize;
        cacheEnabled = maxArcCacheSize > 0;
    }

    /*
     * (non-Javadoc)
     * 
     * @see edu.cmu.sphinx.util.props.Configurable#getName()
     */
    public String getName() {
        return name;
    }

    /*
     * (non-Javadoc)
     * 
     * @see edu.cmu.sphinx.linguist.Linguist#allocate()
     */
    public void allocate() throws IOException {
        dictionary.allocate();
        acousticModel.allocate();
        languageModel.allocate();
        compileGrammar();
        acousticModel = null;
    }

    /*
     * (non-Javadoc)
     * 
     * @see edu.cmu.sphinx.linguist.Linguist#deallocate()
     */
    public void deallocate() {
        acousticModel = null;
        logMath = null;
        dictionary = null;
    }

    /*
     * (non-Javadoc)
     * 
     * @see edu.cmu.sphinx.linguist.Linguist#getSearchGraph()
     */
    public SearchGraph getSearchGraph() {
        return searchGraph;
    }

    /**
     * 
     * Called before a recognition
     */
    public void startRecognition() {
        languageModel.start();
    }

    /**
     * Called after a recognition
     */
    public void stopRecognition() {
        languageModel.stop();
    }

    /**
     * Retrieves the language model for this linguist
     * 
     * @return the language model (or null if there is none)
     */
    public LanguageModel getLanguageModel() {
        return languageModel;
    }

    /**
     * retrieves the initial language state
     * 
     * @return the initial language state
     */
    private SearchState getInitialSearchState() {
        InitialWordNode node = hmmTree.getInitialNode();
        return new LexTreeWordState(node, node.getParent(), WordSequence
                .getWordSequence(sentenceStartWordArray).trim(
                        languageModel.getMaxDepth() - 1), 0f, logOne, logOne);
    }

    /**
     * Compiles the n-gram into a lex tree that is used during the search
     */
    protected void compileGrammar() {
        Timer.start("compile");
        
        sentenceEndWord = dictionary.getSentenceEndWord();
        sentenceStartWordArray = new Word[1];
        sentenceStartWordArray[0] = dictionary.getSentenceStartWord();
        
        hmmPool = new HMMPool(acousticModel, logger, unitManager);

        hmmTree = new HMMTree(hmmPool, dictionary, languageModel,
                addFillerWords, languageWeight);

        hmmPool.dumpInfo();

        Timer.stop("compile");
        // Now that we are all done, dump out some interesting
        // information about the process

        searchGraph = new LexTreeSearchGraph(getInitialSearchState());
    }


    class LexTreeSearchGraph implements SearchGraph {
        /**
         * An array of classes that represents the order in which the states
         * will be returned.
         */

        private SearchState initialState;

        /**
         * Constructs a search graph with the given initial state
         * 
         * @param initialState
         *                the initial state
         */
        LexTreeSearchGraph(SearchState initialState) {
            this.initialState = initialState;
        }

        /*
         * (non-Javadoc)
         * 
         * @see edu.cmu.sphinx.linguist.SearchGraph#getInitialState()
         */
        public SearchState getInitialState() {
            return initialState;
        }

        /*
         * (non-Javadoc)
         * 
         * @see edu.cmu.sphinx.linguist.SearchGraph#getSearchStateOrder()
         */
        public int getNumStateOrder() {
            return 6;
        }
    }

    /**
     * The LexTreeLinguist returns lanague states to the search manager. This
     * class forms the base implementation for all language states returned.
     * This LexTreeState keeps track of the probability of entering this state (a
     * language+insertion probability) as well as the unit history. The unit
     * history consists of the LexTree nodes that correspond to the left,
     * center and right contexts.
     * 
     * This is an abstract class, subclasses must implement the getSuccessorss
     * method.
     */
    abstract class LexTreeState implements SearchState, SearchStateArc {
        private Node node;
        private WordSequence wordSequence;
        float currentSmearTerm;
        float currentSmearProb;

        /**
         * Creates a LexTreeState.
         * 
         * @param node
         *                the node associated with this state
         * 
         * @param wordSequence
         *                the history of words up until this point
         *  
         */
        LexTreeState(Node node, WordSequence wordSequence, float smearTerm,
                float smearProb) {
            this.node = node;
            this.wordSequence = wordSequence;
            currentSmearTerm = smearTerm;
            currentSmearProb = smearProb;
        }

        /**
         * Gets the unique signature for this state. The signature building
         * code is slow and should only be used for non-time-critical tasks
         * such as plotting states.
         * 
         * @return the signature
         */
        public String getSignature() {
            return "lts-" + node.hashCode() + "-ws-" + wordSequence;
        }

        public float getSmearTerm() {
            return currentSmearTerm;
        }

        public float getSmearProb() {
            return currentSmearProb;
        }

        /**
         * Generate a hashcode for an object
         * 
         * @return the hashcode
         */
        public int hashCode() {
            int hashCode = fullWordHistories
                    ? wordSequence.hashCode() * 37
                    : 37;
            hashCode += node.hashCode();
            return hashCode;
        }

        /**
         * Determines if the given object is equal to this object
         * 
         * @param o
         *                the object to test
         * @return <code>true</code> if the object is equal to this
         */
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            } else if (o instanceof LexTreeState) {
                LexTreeState other = (LexTreeState) o;
                boolean wordSequenceMatch = fullWordHistories ? wordSequence
                        .equals(other.wordSequence) : true;
                return node == other.node && wordSequenceMatch;
            } else {
                return false;
            }
        }

        /**
         * Gets a successor to this search state
         * 
         * @return the sucessor state
         */
        public SearchState getState() {
            return this;
        }

        /**
         * Gets the composite probability of entering this state
         * 
         * @return the log probability
         */
        public float getProbability() {
            return getLanguageProbability() + getAcousticProbability()
                    + getInsertionProbability();
        }

        /**
         * Gets the language probability of entering this state
         * 
         * @return the log probability
         */
        public float getLanguageProbability() {
            return logOne;
        }

        /**
         * Gets the language probability of entering this state
         * 
         * @return the log probability
         */
        public float getAcousticProbability() {
            return logOne;
        }

        /**
         * Gets the insertion probability of entering this state
         * 
         * @return the log probability
         */
        public float getInsertionProbability() {
            return logOne;
        }

        /**
         * Determines if this is an emitting state
         * 
         * @return <code>true</code> if this is an emitting state.
         */
        public boolean isEmitting() {
            return false;
        }

        /**
         * Determines if this is a final state
         * 
         * @return <code>true</code> if this is an final state.
         */
        public boolean isFinal() {
            return false;
        }

        /**
         * Gets the hmm tree node representing the unit
         * 
         * @return the unit lex node
         */
        protected Node getNode() {
            return node;
        }

        /**
         * Returns the word sequence for this state
         * 
         * @return the word sequence
         */
        public WordSequence getWordHistory() {
            return wordSequence;
        }

        public Object getLexState() {
            return node;
        }

        /**
         * Returns the list of successors to this state
         * 
         * @return a list of SearchState objects
         */
        public SearchStateArc[] getSuccessors() {
            SearchStateArc[] arcs = getCachedArcs();
            if (arcs == null) {
                arcs = getSuccessors(node);
                putCachedArcs(arcs); 
            } 
            return arcs;
        }

        /**
         * Returns the list of successors to this state
         * 
         * @return a list of SearchState objects
         */
        protected SearchStateArc[] getSuccessors(Node theNode) {
            Collection nodes = theNode.getSuccessors();
            SearchStateArc[] arcs = new SearchStateArc[nodes.size()];
            Iterator iter = nodes.iterator();
            // System.out.println("Arc: "+ this);
            for (int i = 0; i < arcs.length; i++) {
                Node nextNode = (Node) iter.next();
                //  System.out.println(" " + nextNode);
                if (nextNode instanceof WordNode) {
                    arcs[i] = createWordStateArc((WordNode) nextNode,
                            (HMMNode) getNode(), this);
                } else if (nextNode instanceof EndNode) {
                    arcs[i] = createEndUnitArc((EndNode) nextNode, this);
                } else {
                    arcs[i] = createUnitStateArc((HMMNode) nextNode, this);
                }
            }
            return arcs;
        }

        /**
         * Creates a word search state for the given word node
         * 
         * @param wordNode
         *                the wordNode
         * 
         * @return the search state for the wordNode
         */
        protected SearchStateArc createWordStateArc(WordNode wordNode,
                HMMNode lastUnit, LexTreeState previous) {
            // System.out.println("CWSA " + wordNode + " fup " + fixupProb);
            float probability = logOne;
            float arcProbability = logOne;
            Word nextWord = wordNode.getWord();
            WordSequence nextWordSequence = wordSequence;
            float smearTerm = previous.getSmearTerm();

            if (!nextWord.isFiller() || nextWord == sentenceEndWord) {
                nextWordSequence = wordSequence.addWord(nextWord, languageModel
                        .getMaxDepth());
                probability = languageModel.getProbability(nextWordSequence);
                smearTerm = getSmearTermFromLanguageModel(nextWordSequence);
                // System.out.println("LP " + nextWordSequence + " " +
                // logProbability);
                probability *= languageWeight;
                // subtract off the previously applied smear probability
                arcProbability = probability - previous.getSmearProb();
            }
            if (nextWord == sentenceEndWord) {
                // System.out.println("LP " + nextWordSequence + " " +
                // logProbability);
                return new LexTreeEndWordState(wordNode, lastUnit,
                        nextWordSequence.trim(languageModel.getMaxDepth() - 1),
                        smearTerm, logOne, arcProbability);
            } else {
                return new LexTreeWordState(wordNode, lastUnit,
                        nextWordSequence.trim(languageModel.getMaxDepth() - 1),
                        smearTerm, logOne, arcProbability);
            }
        }

        /**
         * Creates a unit search state for the given unit node
         * 
         * @param hmmNode
         *                the unit node
         * 
         * @return the search state
         */
        SearchStateArc createUnitStateArc(HMMNode hmmNode, LexTreeState previous) {
            SearchStateArc arc;
            // System.out.println("CUSA " + hmmNode);
            float insertionProbability = calculateInsertionProbability(hmmNode);
            float probability = getUnigramSmear(hmmNode)
                    + previous.getSmearTerm();
            float arcProbability = probability - previous.getSmearProb();

            // if we want a unit state create it, otherwise
            // get the first hmm state of the unit

            if (generateUnitStates) {
                arc = new LexTreeUnitState(hmmNode, getWordHistory(), previous
                        .getSmearTerm(), probability, arcProbability,
                        insertionProbability);
            } else {
                HMM hmm = hmmNode.getHMM();
                arc = new LexTreeHMMState(hmmNode, getWordHistory(), previous
                        .getSmearTerm(), probability, hmm.getInitialState(),
                        arcProbability, insertionProbability, logOne, null);
            }
            return arc;
        }

        /**
         * Creates a unit search state for the given unit node
         * 
         * @param endNode
         *                the unit node
         * @param previous
         *                the previous state
         * 
         * @return the search state
         */
        SearchStateArc createEndUnitArc(EndNode endNode, LexTreeState previous) {
            float probability = getUnigramSmear(endNode)
                    + previous.getSmearTerm();
            float arcProbability = probability - previous.getSmearProb();
            float insertionProbability = calculateInsertionProbability(endNode);
            return new LexTreeEndUnitState(endNode, getWordHistory(), previous
                    .getSmearTerm(), probability, arcProbability,
                    insertionProbability);
        }

        /**
         * Returns the string representation of this object
         * 
         * @return the string representation
         */
        public String toString() {
            return "lt-" + node + " " + getProbability() + "{" + wordSequence
                    + "}";
        }

        /**
         * Returns a pretty version of the string representation for this
         * object
         * 
         * @return a pretty string
         */
        public String toPrettyString() {
            return toString();
        }

        /**
         * Gets the successor arcs for this state from the cache
         *
         * @return the next set of arcs for this state, or null if
         * none can be found or if caching is disabled.
         */
        SearchStateArc[] getCachedArcs() {
            if (cacheEnabled) {
                SearchStateArc[] arcs = (SearchStateArc[]) arcCache.get(this);
                if (arcs != null) {
                    cacheHits++;
                }
                if (++cacheTrys % 1000000 == 0) {
                    System.out.println("Hits: " + cacheHits 
                            + " of " + cacheTrys + " " + 
                            ((float) cacheHits) / cacheTrys * 100f);
                }
                return arcs;
            } else {
                return null;
            }
        }

        /**
         * Puts the set of arcs into the cache
         *
         * @param arcs the arcs to cache.
         */
        void putCachedArcs(SearchStateArc[] arcs) {
            if (cacheEnabled) {
                arcCache.put(this, arcs);
            }
        }

        abstract public int getOrder();
    }

    /**
     * Represents a unit in the search space
     */
    public class LexTreeEndUnitState extends LexTreeState
            implements UnitSearchState {

        float logLanguageProbability;
        float logInsertionProbability;

        /**
         * Constructs a LexTreeUnitState
         * 
         * @param wordSequence
         *                the history of words
         */
        LexTreeEndUnitState(EndNode endNode, WordSequence wordSequence,
                float smearTerm, float smearProb, float languageProbability,
                float insertionProbability) {
            super(endNode, wordSequence, smearTerm, smearProb);
            logLanguageProbability = languageProbability;
            logInsertionProbability = insertionProbability;
            // System.out.println("LTEUS " + logLanguageProbability + " " +
            // logInsertionProbability);
        }

        /**
         * Returns the base unit assciated with this state
         * 
         * @return the base unit
         */
        public Unit getUnit() {
            return getEndNode().getBaseUnit();
        }

        /**
         * Generate a hashcode for an object
         * 
         * @return the hashcode
         */
        public int hashCode() {
            return super.hashCode() * 17 + 423;
        }

        /**
         * Gets the acoustic probability of entering this state
         * 
         * @return the log probability
         */
        public float getInsertionProbability() {
            return logInsertionProbability;
        }

        /**
         * Gets the language probability of entering this state
         * 
         * @return the log probability
         */
        public float getLanguageProbability() {
            return logLanguageProbability;
        }

        /**
         * Determines if the given object is equal to this object
         * 
         * @param o
         *                the object to test
         * @return <code>true</code> if the object is equal to this
         */
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            } else if (o instanceof LexTreeEndUnitState) {
                LexTreeEndUnitState other = (LexTreeEndUnitState) o;
                return super.equals(o);
            } else {
                return false;
            }
        }

        /**
         * Returns the unit node for this state
         * 
         * @return the unit node
         */
        private EndNode getEndNode() {
            return (EndNode) getNode();
        }

        /**
         * Returns the list of successors to this state
         * 
         * @return a list of SearchState objects
         */
        public SearchStateArc[] getSuccessors() {
            SearchStateArc[] arcs = getCachedArcs();
            if (arcs == null) {
                HMMNode[] nodes = getHMMNodes(getEndNode());
                arcs = new SearchStateArc[nodes.length];

                if (generateUnitStates) {
                    for (int i = 0; i < nodes.length; i++) {
                        arcs[i] = new LexTreeUnitState(nodes[i], 
                            getWordHistory(), getSmearTerm(), 
                            getSmearProb(), logOne, logOne,
                            this.getNode());
                    }
                } else {
                    for (int i = 0; i < nodes.length; i++) {
                        HMM hmm = nodes[i].getHMM();
                        arcs[i] = new LexTreeHMMState(nodes[i], 
                                getWordHistory(), getSmearTerm(), 
                                getSmearProb(), hmm.getInitialState(), 
                                logOne, logOne, logOne, this.getNode());
                    }
                }
                putCachedArcs(arcs);
            }
            return arcs;
        }

        public String toString() {
            return super.toString() + " EndUnit";
        }

        public int getOrder() {
            return 3;
        }
    }

    /**
     * Represents a unit in the search space
     */
    public class LexTreeUnitState extends LexTreeState
            implements UnitSearchState {

        private float logInsertionProbability;
        private float logLanguageProbability;
        private Node parentNode = null;
        private int hashCode = -1;

        /**
         * Constructs a LexTreeUnitState
         * 
         * @param wordSequence
         *                the history of words
         */
        LexTreeUnitState(HMMNode hmmNode, WordSequence wordSequence,
                float smearTerm, float smearProb, float languageProbability,
                float insertionProbability) {
            this(hmmNode, wordSequence, smearTerm, smearProb,
                    languageProbability, insertionProbability, null);
        }

        /**
         * Constructs a LexTreeUnitState
         * 
         * @param wordSequence
         *                the history of words
         */
        LexTreeUnitState(HMMNode hmmNode, WordSequence wordSequence,
                float smearTerm, float smearProb, float languageProbability,
                float insertionProbability, Node parentNode) {
            super(hmmNode, wordSequence, smearTerm, smearProb);
            this.logInsertionProbability = insertionProbability;
            this.logLanguageProbability = languageProbability;
            this.parentNode = parentNode;
        }

        /**
         * Returns the base unit assciated with this state
         * 
         * @return the base unit
         */
        public Unit getUnit() {
            return getHMMNode().getBaseUnit();
        }

        /**
         * Generate a hashcode for an object
         * 
         * @return the hashcode
         */
        public int hashCode() {
            if (hashCode == -1) {
                hashCode = super.hashCode() * 17 + 421;
                if (parentNode != null) {
                    hashCode *= 432;
                    hashCode += parentNode.hashCode();
                }
            }
            return hashCode;
        }

        /**
         * Determines if the given object is equal to this object
         * 
         * @param o
         *                the object to test
         * @return <code>true</code> if the object is equal to this
         */
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            } else if (o instanceof LexTreeUnitState) {
                LexTreeUnitState other = (LexTreeUnitState) o;
                return super.equals(o) && parentNode == other.parentNode;
            } else {
                return false;
            }
        }

        /**
         * Returns the unit node for this state
         * 
         * @return the unit node
         */
        private HMMNode getHMMNode() {
            return (HMMNode) getNode();
        }

        /**
         * Returns the list of successors to this state
         * 
         * @return a list of SearchState objects
         */
        public SearchStateArc[] getSuccessors() {
            SearchStateArc[] arcs = new SearchStateArc[1];
            HMM hmm = getHMMNode().getHMM();
            arcs[0] = new LexTreeHMMState(getHMMNode(), getWordHistory(),
                    getSmearTerm(), getSmearProb(), hmm.getInitialState(),
                    logOne, logOne, logOne, parentNode);
            return arcs;
        }

        public String toString() {
            return super.toString() + " unit";
        }

        /**
         * Gets the acoustic probability of entering this state
         * 
         * @return the log probability
         */
        public float getInsertionProbability() {
            return logInsertionProbability;
        }

        /**
         * Gets the language probability of entering this state
         * 
         * @return the log probability
         */
        public float getLanguageProbability() {
            return logLanguageProbability;
        }

        public int getOrder() {
            return 4;
        }
    }

    /**
     * Represents a HMM state in the search space
     */
    public class LexTreeHMMState extends LexTreeState implements HMMSearchState {

        private HMMState hmmState;
        private float logLanguageProbability;
        private float logInsertionProbability;
        private float logAcousticProbability;
        private Node parentNode;
        int hashCode = -1;

        /**
         * Constructs a LexTreeHMMState
         * 
         * @param hmmNode
         *                the hmm state associated with this unit
         * 
         * @param wordSequence
         *                the word history
         * 
         * @param languageProbability
         *                the probability of the transition
         * @param insertionProbability
         *                the probability of the transition
         * @param acousticProbability
         *                the probability of the transition occuring
         */
        LexTreeHMMState(HMMNode hmmNode, WordSequence wordSequence,
                float smearTerm, float smearProb, HMMState hmmState,
                float languageProbability, float insertionProbability,
                float acousticProbability, Node parentNode) {
            super(hmmNode, wordSequence, smearTerm, smearProb);
            this.hmmState = hmmState;
            this.parentNode = parentNode;
            this.logLanguageProbability = languageProbability;
            this.logInsertionProbability = insertionProbability;
            this.logAcousticProbability = acousticProbability;
        }

        /**
         * Gets the ID for this state
         * 
         * @return the ID
         */
        public String getSignature() {
            return super.getSignature() + "-HMM-" + hmmState.getState();
        }

        /**
         * returns the hmm state associated with this state
         * 
         * @return the hmm state
         */
        public HMMState getHMMState() {
            return hmmState;
        }

        /**
         * Generate a hashcode for an object
         * 
         * @return the hashcode
         */
        public int hashCode() {
            if (hashCode == -1) {
                hashCode = super.hashCode() * 29 + (hmmState.getState() + 1);
                if (parentNode != null) {
                    hashCode *= 377;
                    hashCode += parentNode.hashCode();
                }
            }
            return hashCode;
        }

        /**
         * Determines if the given object is equal to this object
         * 
         * @param o
         *                the object to test
         * @return <code>true</code> if the object is equal to this
         */
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            } else if (o instanceof LexTreeHMMState) {
                LexTreeHMMState other = (LexTreeHMMState) o;
                return super.equals(o) && hmmState == other.hmmState
                        && parentNode == other.parentNode;
            } else {
                return false;
            }
        }

        /**
         * Gets the acoustic probability of entering this state
         * 
         * @return the log probability
         */
        public float getAcousticProbability() {
            return logAcousticProbability;
        }

        /**
         * Gets the language probability of entering this state
         * 
         * @return the log probability
         */
        public float getLanguageProbability() {
            return logLanguageProbability;
        }

        /**
         * Gets the language probability of entering this state
         * 
         * @return the log probability
         */
        public float getInsertionProbability() {
            return logInsertionProbability;
        }

        /**
         * Retreives the set of successors for this state
         * 
         * @return the list of sucessor states
         */
        public SearchStateArc[] getSuccessors() {
            SearchStateArc[] nextStates = getCachedArcs();
            if (nextStates == null) {

                // if this is an exit state, we are transitioning to a
                // new unit or to a word end.

                if (hmmState.isExitState()) {
                    if (parentNode == null) {
                        nextStates = super.getSuccessors();
                    } else {
                        nextStates = super.getSuccessors(parentNode);
                    }
                } else {
                    // The current hmm state is not an exit state, so we
                    // just go through the next set of successors

                    HMMStateArc[] arcs = hmmState.getSuccessors();
                    nextStates = new SearchStateArc[arcs.length];
                    for (int i = 0; i < arcs.length; i++) {
                        HMMStateArc arc = arcs[i];
                        if (arc.getHMMState().isEmitting()) {
                            // if its a self loop and the prob. matches
                            // reuse the state
                            if (arc.getHMMState() == hmmState
                                    && logAcousticProbability == arc
                                            .getLogProbability()) {
                                nextStates[i] = this;
                            } else {
                                nextStates[i] = new LexTreeHMMState(
                                        (HMMNode) getNode(), getWordHistory(),
                                        getSmearTerm(), getSmearProb(), 
                                        arc.getHMMState(), logOne, logOne, 
                                        arc.getLogProbability(), parentNode);
                            }
                        } else {
                            nextStates[i] = new LexTreeNonEmittingHMMState(
                                    (HMMNode) getNode(), getWordHistory(),
                                    getSmearTerm(), getSmearProb(), 
                                    arc .getHMMState(),
                                    arc.getLogProbability(), parentNode);
                        }
                    }
                }
                putCachedArcs(nextStates);
            }
            return nextStates;
        }

        /**
         * Determines if this is an emitting state
         */
        public boolean isEmitting() {
            return hmmState.isEmitting();
        }

        public String toString() {
            return super.toString() + " hmm:" + hmmState;
        }

        public int getOrder() {
            return 5;
        }
    }

    /**
     * Represents a non emitting hmm state
     */
    public class LexTreeNonEmittingHMMState extends LexTreeHMMState {

        /**
         * Constructs a NonEmittingLexTreeHMMState
         * 
         * @param hmmState
         *                the hmm state associated with this unit
         * 
         * @param wordSequence
         *                the word history
         * 
         * @param probability
         *                the probability of the transition occuring
         */
        LexTreeNonEmittingHMMState(HMMNode hmmNode, WordSequence wordSequence,
                float smearTerm, float smearProb, HMMState hmmState,
                float probability, Node parentNode) {
            super(hmmNode, wordSequence, smearTerm, smearProb, hmmState,
                    logOne, logOne, probability, parentNode);
        }

        public int getOrder() {
            return 0;
        }
    }

    /**
     * Represents a word state in the search space
     */
    public class LexTreeWordState extends LexTreeState
            implements
                WordSearchState {

        private HMMNode lastNode;
        private float logLanguageProbability;

        /**
         * Constructs a LexTreeWordState
         * 
         * @param wordNode
         *                the word node
         * 
         * @param wordSequence
         *                the sequence of words triphone context
         * 
         * @param logProbability
         *                the probability of this word occuring
         *  
         */
        LexTreeWordState(WordNode wordNode, HMMNode lastNode,
                WordSequence wordSequence, float smearTerm, float smearProb,
                float logProbability) {

            super(wordNode, wordSequence, smearTerm, smearProb);
            // System.out.println("LTWS " + wordSequence);
            this.lastNode = lastNode;
            this.logLanguageProbability = logProbability;
        }

        /**
         * Gets the word pronunciation for this state
         * 
         * @return the pronunciation for this word
         */
        public Pronunciation getPronunciation() {
            return ((WordNode) getNode()).getPronunciation();
        }

        /**
         * Determines if this is a final state
         * 
         * @return <code>true</code> if this is an final state.
         */
        public boolean isFinal() {
            return getPronunciation().getWord().equals(sentenceEndWord);
        }

        /**
         * Generate a hashcode for an object
         * 
         * @return the hashcode
         */
        public int hashCode() {
            return super.hashCode() * 41 + lastNode.hashCode();
        }

        /**
         * Gets the unique signature for this state. The signature building
         * code is slow and should only be used for non-time-critical tasks
         * such as plotting states.
         * 
         * @return the signature
         */
        public String getSignature() {
            return super.getSignature() + "-ln-" + lastNode.hashCode();
        }

        /**
         * Determines if the given object is equal to this object
         * 
         * @param o
         *                the object to test
         * @return <code>true</code> if the object is equal to this
         */
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            } else if (o instanceof LexTreeWordState) {
                LexTreeWordState other = (LexTreeWordState) o;
                return super.equals(o) && lastNode == other.lastNode;
            } else {
                return false;
            }
        }

        /**
         * Gets the language probability of entering this state
         * 
         * @return the log probability
         */
        public float getLanguageProbability() {
            return logLanguageProbability;
        }

        /**
         * Returns the list of successors to this state
         * 
         * @return a list of SearchState objects
         */
        public SearchStateArc[] getSuccessors() {
            SearchStateArc[] arcs = getCachedArcs();
            if (arcs == null) {
                arcs = EMPTY_ARC;
                WordNode wordNode = (WordNode) getNode();

                if (wordNode.getWord() != sentenceEndWord) {
                    int index = 0;
                    List list = new ArrayList();
                    Unit[] rc = lastNode.getRC();
                    Unit left = wordNode.getLastUnit();

                    for (int i = 0; i < rc.length; i++) {
                        Collection epList = hmmTree.getEntryPoint(left, rc[i]);
                        list.addAll(epList);
                    }

                    // add a link to every possible entry point as well
                    // as link to the </s> node
                    arcs = new SearchStateArc[list.size() + 1];
                    for (Iterator i = list.iterator(); i.hasNext();) {
                        HMMNode node = (HMMNode) i.next();
                        arcs[index++] = createUnitStateArc(node, this);
                    }

                    // now add the link to the end of sentence arc:

                    arcs[index++] = createWordStateArc(hmmTree
                            .getSentenceEndWordNode(), lastNode, this);
                }
                putCachedArcs(arcs);
            }
            return arcs;
        }

        public int getOrder() {
            return 1;
        }

        /**
         * Returns true if this LexTreeWordState indicates the start of a word.
         * Returns false if this LexTreeWordState indicates the end of a word.
         *
         * @return true if this LexTreeWordState indicates the start of a word,
         *         false if this LexTreeWordState indicates the end of a word
         */
        public boolean isWordStart() {
            return false;
        }        
    }

    /**
     * Represents the final end of utterance word
     */
    public class LexTreeEndWordState extends LexTreeWordState
            implements
                WordSearchState {

        /**
         * Constructs a LexTreeWordState
         * 
         * @param wordNode
         *                the word node
         * 
         * @param lastNode
         *                the previous word node
         * 
         * @param wordSequence
         *                the sequence of words triphone context
         * 
         * @param logProbability
         *                the probability of this word occuring
         *  
         */
        LexTreeEndWordState(WordNode wordNode, HMMNode lastNode,
                WordSequence wordSequence, float smearTerm, float smearProb,
                float logProbability) {
            super(wordNode, lastNode, wordSequence, smearTerm, smearProb,
                    logProbability);
        }

        public int getOrder() {
            return 2;
        }

    }

    /**
     * Determines the insertion probability for the given unit lex node
     * 
     * @param unitNode
     *                the unit lex node
     * 
     * @return the insertion probability
     */
    private float calculateInsertionProbability(UnitNode unitNode) {
        int type =  unitNode.getType();

        if (type == UnitNode.SIMPLE_UNIT) {
            return logUnitInsertionProbability;
        } else if (type == UnitNode.WORD_BEGINNING_UNIT) {
            return logUnitInsertionProbability + logWordInsertionProbability;
        } else if (type == UnitNode.SILENCE_UNIT) {
            return logSilenceInsertionProbability;
        } else { // must be filler
            return logFillerInsertionProbability;
        }
    }

    /**
     * Retrieves the unigram smear from the given node
     * 
     * @return the unigram smear
     */
    private float getUnigramSmear(Node node) {
        float prob;
        if (wantUnigramSmear) {
            prob = node.getUnigramProbability() * unigramSmearWeight;
        } else {
            prob = logOne;
        }
        return prob;
    }

    /**
     * Returns the smear term for the given word sequence
     * 
     * @param ws
     *                the word sequence
     * @return the smear term for the word sequence
     */
    private float getSmearTermFromLanguageModel(WordSequence ws) {
        return languageModel.getSmear(ws);
    }

    /**
     * Gets the set of hmm nodes associated with the given end node
     * 
     * @param endNode
     *                the end node
     * 
     * @return an array of associated hmm nodes
     */
    private HMMNode[] getHMMNodes(EndNode endNode) {
        return hmmTree.getHMMNodes(endNode);
    }

    class ArcCache extends LinkedHashMap {
        protected boolean removeEldestEntry(Map.Entry eldest) {
            return size() > maxArcCacheSize;
        }
    }
}

