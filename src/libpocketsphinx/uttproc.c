/* -*- c-basic-offset: 4; indent-tabs-mode: nil -*- */
/* ====================================================================
 * Copyright (c) 1999-2004 Carnegie Mellon University.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * This work was supported in part by funding from the Defense Advanced 
 * Research Projects Agency and the National Science Foundation of the 
 * United States of America, and the CMU Sphinx Speech Consortium.
 *
 * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
 * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ====================================================================
 *
 */
/*
 * uttproc.c -- Process utterance.
 * 
 * HISTORY
 * 
 * 22-Nov-2004  M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon Univ.
 *              Modified to use senscr module for senone score computation.
 * 
 * 18-Nov-2004  M K Ravishankar (rkm@cs.cmu.edu) at Carnegie Mellon Univ.
 *              uttproc_feat2rawfr() is buggy; set it to ignore comp2rawfr[].
 * 
 * Revision 1.18  2004/11/13 00:38:44  egouvea
 * Replaced most printf with E_INFO (or E_WARN or...). Changed the output
 * of the time_align code so it's consistent with the other decoder modes
 * (allphone, normal decoding etc). Added the file utt id to the
 * time_align output.
 *
 * Revision 1.17  2004/07/23 23:36:34  egouvea
 * Ravi's merge, with the latest fixes in the FSG code, and making the log files generated by FSG, LM, and allphone have the same 'look and feel', with the backtrace information presented consistently
 *
 * Revision 1.8  2004/07/20 20:48:40  rkm
 * Added uttproc_load_fsg().
 *
 * Revision 1.7  2004/07/20 13:40:55  rkm
 * Added FSG get/set start/final state functions.
 *
 * Revision 1.6  2004/07/16 19:55:28  rkm
 * Added state information to hypothesis.
 *
 * Revision 1.16  2004/07/16 00:57:12  egouvea
 * Added Ravi's implementation of FSG support.
 *
 * Revision 1.5  2004/07/07 13:56:33  rkm
 * Added reporting of (acoustic score - best senone score)/frame
 *
 * Revision 1.4  2004/06/22 15:35:46  rkm
 * Added partial result reporting options in batch mode
 *
 * Revision 1.3  2004/06/16 17:48:03  rkm
 * Imported pscr-based stuff from fbs_main.c
 *
 * Revision 1.2  2004/05/27 14:22:57  rkm
 * FSG cross-word triphones completed (but for single-phone words)
 *
 * Revision 1.2  2004/03/02 15:33:39  rkm
 * FSG bug fixes
 *
 * Revision 1.14  2004/03/02 04:10:14  rkm
 * FSG bugfix: need to get senscores every utt
 *
 * Revision 1.13  2004/03/01 20:30:56  rkm
 * *** empty log message ***
 *
 * Revision 1.12  2004/03/01 20:21:33  rkm
 * *** empty log message ***
 *
 * Revision 1.11  2004/02/27 21:01:25  rkm
 * Many bug fixes in multiple FSGs
 *
 * Revision 1.10  2004/02/27 19:33:01  rkm
 * *** empty log message ***
 *
 * Revision 1.9  2004/02/27 16:15:13  rkm
 * Added FSG switching
 *
 * Revision 1.8  2004/02/27 15:05:21  rkm
 * *** empty log message ***
 *
 * Revision 1.7  2004/02/26 01:14:48  rkm
 * *** empty log message ***
 *
 * Revision 1.6  2004/02/25 15:08:19  rkm
 * *** empty log message ***
 *
 * Revision 1.5  2004/02/24 18:13:05  rkm
 * Added NULL transition handling
 *
 * Revision 1.4  2004/02/23 15:53:45  rkm
 * Renamed from fst to fsg
 *
 * Revision 1.3  2004/02/23 15:09:50  rkm
 * *** empty log message ***
 *
 * Revision 1.2  2004/02/19 21:16:54  rkm
 * Added fsg_search.{c,h}
 *
 * Revision 1.1.1.1  2003/12/03 20:05:04  rkm
 * Initial CVS repository
 *
 * Revision 1.15  2001/12/11 00:24:48  lenzo
 * Acknowledgement in License.
 *
 * Revision 1.14  2001/12/07 20:32:59  lenzo
 * No unistd.h on Windows.
 *
 * Revision 1.13  2001/12/07 17:46:00  lenzo
 * Un-ifdef the include for <unistd.h>
 *
 * Revision 1.12  2001/12/07 17:30:02  lenzo
 * Clean up and remove extra lines.
 *
 * Revision 1.11  2001/12/07 05:09:30  lenzo
 * License.xsxc
 *
 * Revision 1.10  2001/12/07 04:27:35  lenzo
 * License cleanup.  Remove conditions on the names.  Rationale: These
 * conditions don't belong in the license itself, but in other fora that
 * offer protection for recognizeable names such as "Carnegie Mellon
 * University" and "Sphinx."  These changes also reduce interoperability
 * issues with other licenses such as the Mozilla Public License and the
 * GPL.  This update changes the top-level license files and removes the
 * old license conditions from each of the files that contained it.
 * All files in this collection fall under the copyright of the top-level
 * LICENSE file.
 *
 * Revision 1.9  2001/10/23 22:20:30  lenzo
 * Change error logging and reporting to the E_* macros that call common
 * functions.  This will obsolete logmsg.[ch] and they will be removed
 * or changed in future versions.
 *
 * Revision 1.8  2001/03/31 00:56:12  lenzo
 * Added <string.h>
 *
 * Revision 1.6  2001/01/25 19:36:28  lenzo
 * Fixing some memory leaks
 *
 * Revision 1.5  2000/12/21 18:04:51  lenzo
 * Fixed a nasty (but small) FRAME_RATE error.  This will need cleanup later.
 *
 * Revision 1.4  2000/12/12 23:01:42  lenzo
 * Rationalizing libs and names some more.  Split a/d and fe libs out.
 *
 * Revision 1.3  2000/12/05 01:45:12  lenzo
 * Restructuring, hear rationalization, warning removal, ANSIfy
 *
 * Revision 1.2  2000/02/08 20:44:32  lenzo
 * Changed uttproc_allphone_cepfile() to uttproc_allphone_file.
 *
 * Revision 1.1.1.1  2000/01/28 22:08:58  lenzo
 * Initial import of sphinx2
 *
 * 09-Jan-00    Kevin Lenzo <lenzo@cs.cmu.edu> at Carnegie Mellon
 *              Altered to accomodate new fe lib.
 * 
 * 30-Oct-98    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Changed rawlogfile mode to READONLY (WIN32).
 * 
 * 10-Sep-98    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Reset uttno to 0 whenever uttproc_set_auto_uttid_prefix() is called.
 * 
 * 10-Sep-98    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Added uttproc_allphone_cepfile(), and minor modifications to support it.
 * 
 * 20-Aug-98    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Bugfix: 
 *              Added call to agc_emax_update() inside uttproc_end_utt().  Added call
 *              to initialize AGC with a reasonable value.
 * 
 * 20-Apr-98    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Added uttproc_set_auto_uttid_prefix().
 * 
 * 11-Apr-98    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Added AGC_NONE test to determining livemode in uttproc_begin_utt().
 *              Added memcpy to mfc2feat_live if AGC_NONE (bugfix).
 * 
 * 22-Jul-97    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Added sampling rate spec in call to fe_init.
 * 
 * 27-May-97    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Added uttprocSetcomp2rawfr() and uttprocGetcomp2rawfr() functions
 *              implemented by Bob Brennan for maintaining multiple lattices.
 * 
 * 04-Apr-97    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Added dictwd_in_lm() check in uttproc_set_context.
 * 
 * 30-Oct-96    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Commented out call to search_dump_lattice_ascii.
 *              Added feature vector padding in mfc2feat_batch ().
 * 
 * 17-Jun-96    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Added uttproc_set_context().
 * 
 * 04-Jun-96    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Added BLOCKING option to uttproc_rawdata, uttproc_cepdata, uttproc_result.
 * 
 * 24-May-96    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Substantially modified to be driven with externally provided data, rather
 *                      than explicitly reading an A/D source.
 *              Added uttproc_abort_utt() and uttproc_partial_result().
 *              Added raw and mfc logging function.
 * 
 * 17-Nov-95    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Added function uttproc_lmupdate().
 * 
 * 17-Nov-95    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Fixed bug in uttproc_feat2rawfr that could return feat2rawfr[-1].
 * 
 * 29-Sep-95    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Added -matchsegfn argument and processing.
 * 
 * 17-Sep-95    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Added autonumbering of utterances (typically used in live mode).
 * 
 * 02-Jul-95    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Added allphone handling.
 * 
 * 13-Jun-95    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Simplified the uttproc interface by combining functions and redefining
 *              others.
 * 
 * 01-Jun-95    M K Ravishankar (rkm@cs) at Carnegie Mellon University
 *              Added uttproc_set_lm() and uttproc_set_startword().
 */

/*
 * BUGS:
 *   - Instead of using query_fwdtree_flag() to determine which first pass to run
 *     (tree or flag), there should be an explicit uttproc_set_firstpass() call.
 */

/* System Headers */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#ifndef _WIN32
#include <sys/resource.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/param.h>
#include <unistd.h> /* dup2() */
#endif

/* SphinxBase headers */
#include <sphinx_config.h>
#include <cmd_ln.h>

/* Local headers */
#include "s2types.h"
#include "ckd_alloc.h"
#include "basic_types.h"
#include "err.h"
#include "s2_semi_mgau.h"
#include "senscr.h"
#include "search_const.h"
#include "msd.h"
#include "strfuncs.h"
#include "linklist.h"
#include "list.h"
#include "dict.h"
#include "lmclass.h"
#include "lm_3g.h"
#include "kb.h"
#include "feat.h"
#include "fe.h"
#include "fixpoint.h"
#include "fbs.h"
#include "search.h"
#include "fsg_search.h"
#include "ckd_alloc.h"
#include "uttproc.h"
#include "posixwin32.h"

#define MAX_UTT_LEN     6000    /* #frames */

typedef enum {
    UTTSTATE_UNDEF = -1,
    UTTSTATE_IDLE = 0,
    UTTSTATE_BEGUN = 1,
    UTTSTATE_ENDED = 2,
    UTTSTATE_STOPPED = 3
} uttstate_t;
static uttstate_t uttstate = UTTSTATE_UNDEF;
/* Used to flag beginning of utterance in livemode. */
static int32 uttstart;

static int32 inputtype;
#define INPUT_UNKNOWN   0
#define INPUT_RAW       1
#define INPUT_MFC       2

static int32 livemode;          /* Iff TRUE, search while input being supplied.  In this
                                   case, CMN, AGC and silence compression cannot be
                                   utterance based */
static int32 utt_ofl;           /* TRUE iff buffer limits overflowed in current utt */
static int32 nosearch = 0;
static int32 fsg_search_mode = FALSE;   /* Using FSM search structure */

/* Feature computation object */
static feat_t *fcb;

/* MFC vectors for entire utt */
static mfcc_t **mfcbuf;
static int32 n_cepfr;          /* #input frames */

/* Feature vectors for entire utt */
static mfcc_t ***feat_buf;
static int32 n_featfr;          /* #features frames */
static int32 n_searchfr;

static FILE *matchfp = NULL;
static FILE *matchsegfp = NULL;

static char *rawlogdir = NULL;
static char *mfclogdir = NULL;
static FILE *rawfp = NULL;
static FILE *mfcfp = NULL;
static char rawfilename[4096];

static int32 samp_hist[5];      /* #Samples in 0-4K, 4K-8K, 8K-16K, 16K-24K, 24K-32K */
static int32 max_samp;

static char *uttid;
static char *uttid_prefix = NULL;
#define UTTIDSIZE       4096
static int32 uttno;             /* A running sequence number assigned to every utterance.  Used as
                                   an id for an utterance if uttid is undefined. */

static search_hyp_t *utt_seghyp = NULL;

static float TotalCPUTime, TotalElapsedTime, TotalSpeechTime;

#if defined(_WIN32) && !defined(GNUWINCE) && !defined(CYGWIN)
#include <windows.h>
static float e_start, e_stop;
static HANDLE pid;
static FILETIME t_create, t_exit, kst, ket, ust, uet;
static double lowscale, highscale;
extern double win32_cputime();
#else /* Not Windows */
static struct rusage start, stop;
static struct timeval e_start, e_stop;
#endif

/* searchlat.c */
void searchlat_set_rescore_lm(char const *lmname);

static fsg_search_t *fsg_search;


#if defined(_WIN32) && !defined(GNUWINCE) && !defined(CYGWIN)

/* The FILETIME manual page says: "It is not recommended that you add
 * and subtract values from the FILETIME structure to obtain relative
 * times."
 */
double
win32_cputime(FILETIME * st, FILETIME * et)
{
    double dt;
    ULARGE_INTEGER l_st = *(ULARGE_INTEGER *) st;
    ULARGE_INTEGER l_et = *(ULARGE_INTEGER *) et;
    LONGLONG ltime;

    ltime = l_et.QuadPart - l_st.QuadPart;

    dt = (ltime * lowscale);

    return (dt);
}

#else

double
MakeSeconds(struct timeval const *s, struct timeval const *e)
/*------------------------------------------------------------------------*
 * Compute an elapsed time from two timeval structs
 */
{
    return ((e->tv_sec - s->tv_sec) +
            ((e->tv_usec - s->tv_usec) / 1000000.0));
}

#endif

/*
 * One time initialization
 */
static void
timing_init(void)
{
#if defined(_WIN32) && !defined(GNUWINCE) && !defined(CYGWIN)
    lowscale = 1e-7;
    highscale = 65536.0 * 65536.0 * lowscale;

    pid = GetCurrentProcess();
#endif

    TotalCPUTime = TotalElapsedTime = TotalSpeechTime = 0.0;
}

/*
 * Start of each utterance
 */
static void
timing_start(void)
{
#if !(defined(_WIN32) && !defined(GNUWINCE) && !defined(CYGWIN))
# if !(defined(_HPUX_SOURCE) || defined(GNUWINCE))
    getrusage(RUSAGE_SELF, &start);
# endif
    gettimeofday(&e_start, 0);
#else                           /* _WIN32 */
# ifdef _WIN32_WCE
    e_start = (float) GetTickCount() / 1000;
# else
    e_start = (float) clock() / CLOCKS_PER_SEC;
    GetProcessTimes(pid, &t_create, &t_exit, &kst, &ust);
# endif /* !_WIN32_WCE */
#endif                          /* _WIN32 */
}

/*
 * End of each utterance
 */
static void
timing_stop(int32 nfr)
{
    if (nfr <= 0)
        return;

    E_INFO(" %5.2f SoS", searchFrame() * 0.01);
    TotalSpeechTime += searchFrame() * 0.01f;

#if defined(_WIN32) && !defined(GNUWINCE) && !defined(CYGWIN)
    /* ---------------- _WIN32 ---------------- */
# ifdef _WIN32_WCE
    e_stop = (float) GetTickCount() / 1000;
# else
    e_stop = (float) clock() / CLOCKS_PER_SEC;
    GetProcessTimes(pid, &t_create, &t_exit, &ket, &uet);
# endif

    E_INFOCONT(", %6.2f sec elapsed", (e_stop - e_start));
    E_INFOCONT(", %5.2f xRT", (e_stop - e_start) / (searchFrame() * 0.01));
# ifndef _WIN32_WCE
    E_INFOCONT(", %6.2f sec CPU", win32_cputime(&ust, &uet));
    E_INFOCONT(", %5.2f xRT",
               win32_cputime(&ust, &uet) / (searchFrame() * 0.01));
# endif

    TotalCPUTime += (float) win32_cputime(&ust, &uet);
    TotalElapsedTime += (e_stop - e_start);
#else
    /* ---------------- Unix ---------------- */
#if !(defined(_HPUX_SOURCE) || defined(GNUWINCE))
    getrusage(RUSAGE_SELF, &stop);
#endif
    gettimeofday(&e_stop, 0);

    E_INFOCONT(", %6.2f sec elapsed", MakeSeconds(&e_start, &e_stop));
    E_INFOCONT(", %5.2f xRT",
               MakeSeconds(&e_start, &e_stop) / (searchFrame() * 0.01));

#ifndef _HPUX_SOURCE
    E_INFOCONT(", %6.2f sec CPU",
               MakeSeconds(&start.ru_utime, &stop.ru_utime));
    E_INFOCONT(", %5.2f xRT",
               MakeSeconds(&start.ru_utime,
                           &stop.ru_utime) / (searchFrame() * 0.01));
#endif

    TotalCPUTime += MakeSeconds(&start.ru_utime, &stop.ru_utime);
    TotalElapsedTime += MakeSeconds(&e_start, &e_stop);
#endif

    E_INFOCONT("\n\n");
}

/*
 * One time cleanup before exiting program
 */
static void
timing_end(void)
{
    E_INFO("\n");

    E_INFO("TOTAL Elapsed time %.2f seconds\n", TotalElapsedTime);
#ifndef _HPUX_SOURCE
    E_INFO("TOTAL CPU time %.2f seconds\n", TotalCPUTime);
#endif
    E_INFO("TOTAL Speech %.2f seconds\n", TotalSpeechTime);

    if (TotalSpeechTime > 0.0) {
        E_INFO("AVERAGE %.2f xRT(Elapsed)",
               TotalElapsedTime / TotalSpeechTime);
#ifndef _HPUX_SOURCE
        E_INFOCONT(", %.2f xRT(CPU)", TotalCPUTime / TotalSpeechTime);
#endif
        E_INFOCONT("\n");
    }
}

static void
feat_alloc(void)
{
    if (!feat_buf) {
        feat_buf = feat_array_alloc(fcb, MAX_UTT_LEN);
        mfcbuf = (mfcc_t **) ckd_calloc_2d(MAX_UTT_LEN + 10, S2_CEP_VECLEN, sizeof(mfcc_t));
    }
}

static void
warn_notidle(char const *func)
{
    if (uttstate != UTTSTATE_IDLE)
        E_WARN("%s called when not in IDLE state\n", func);
}

int32
uttproc_get_featbuf(mfcc_t ****feat)
{
    *feat = feat_buf;
    return n_featfr;
}

static void
uttproc_fsg_search_fwd(void)
{
    int32 best;

    if (cmd_ln_boolean("-compallsen")) {
        best = senscr_all(feat_buf[n_searchfr], n_searchfr);
    }
    else {
        fsg_search_sen_active(fsg_search);
        best = senscr_active(feat_buf[n_searchfr], n_searchfr);
    }

    /* Note the best senone score for this frame */
    search_set_topsen_score(fsg_search_frame(fsg_search), best);

    fsg_search_frame_fwd(fsg_search);
}


/* Convert all given mfc vectors to feature vectors, and search one frame */
static int32
uttproc_frame(void)
{
    int32 pr, frm;
    char *str;
    search_hyp_t *hyp;

    /* Search one frame */
    if (fsg_search_mode)
        uttproc_fsg_search_fwd();
    else if (cmd_ln_boolean("-fwdtree"))
        search_fwd(feat_buf[n_searchfr]);
    else
        search_fwdflat_frame(feat_buf[n_searchfr]);
    ++n_searchfr;

    pr = cmd_ln_boolean("-phypdump");
    if ((pr > 0) && ((n_searchfr % pr) == 1)) {
        /* Report partial result string */
        uttproc_partial_result(&frm, &str);
        printf("PART[%d]: %s\n", frm, str);
        fflush(stdout);
    }

    pr = cmd_ln_boolean("-phypsegdump");
    if ((pr > 0) && ((n_searchfr % pr) == 1)) {
        /* Report partial result segmentation */
        uttproc_partial_result_seg(&frm, &hyp);
        printf("PARTSEG[%d]:", frm);
        for (; hyp; hyp = hyp->next)
            printf(" %s %d %d", hyp->word, hyp->sf, hyp->ef);
        printf("\n");
        fflush(stdout);
    }

    return 0;
}

static void
fwdflat_search(int32 n_frames)
{
    int32 i;

    search_fwdflat_start();

    for (i = 0; i < n_frames; ++i)
        search_fwdflat_frame(feat_buf[i]);

    search_fwdflat_finish();
}

static void
write_results(char const *hyp, int32 aborted)
{
    search_hyp_t *seghyp;       /* Hyp with word segmentation information */
    int32 i;

    /* Check if need to autonumber utterances */
    if (matchfp) {
        fprintf(matchfp, "%s (%s %s %d)\n",
                hyp, uttid, aborted ? "[ABORTED]" : "",
                search_get_score());
        fflush(matchfp);
    }

    /* Changed this to use Sphinx3 format */
    if (matchsegfp) {
        seghyp = search_get_hyp();
        fprintf(matchsegfp, "%s S %d T %d A %d L %d", uttid,
                0, /* FIXME: scaling factors not recorded? */
                search_get_score(),
                search_get_score() - search_get_lscr(),
                search_get_lscr());
        for (i = 0; seghyp[i].wid >= 0; i++) {
            fprintf(matchsegfp, " %d %d %d %s",
                    seghyp[i].sf,
                    seghyp[i].ascr,
                    lm3g_raw_score(seghyp[i].lscr),
                    kb_get_word_str(seghyp[i].wid));
        }
        fprintf(matchsegfp, " %d\n", searchFrame());
        fflush(matchsegfp);
    }

#if 0
    {
        char const *dumplatdir;
        if ((dumplatdir = cmd_ln_str("-dumplatdir")) != NULL) {
            char fplatfile[1024];

            sprintf(fplatfile, "%s/%s.fplat", dumplatdir, uttid);
            search_dump_lattice_ascii(fplatfile);
        }
    }
#endif                          /* 0 */
}

static void
uttproc_windup(int32 * fr, char **hyp)
{
    /* Wind up first pass and run next pass, if necessary */
    if (fsg_search_mode)
        fsg_search_utt_end(fsg_search);
    else {
        if (cmd_ln_boolean("-fwdtree")) {
            search_finish_fwd();

            if (cmd_ln_boolean("-fwdflat") && (searchFrame() > 0))
                fwdflat_search(n_featfr);
        }
        else
            search_fwdflat_finish();

        /* Run bestpath pass if specified */
        /* FIXME: If we are doing N-best we also need to do this. */
        if ((searchFrame() > 0) && cmd_ln_boolean("-bestpath"))
            bestpath_search();
    }

    search_result(fr, hyp);

    write_results(*hyp, 0);

    timing_stop(*fr);

    uttstate = UTTSTATE_IDLE;
}

/*
 * One time initialization
 */

static fe_t *fe;

int32
uttproc_init(void)
{
    char const *fn;

    if (uttstate != UTTSTATE_UNDEF) {
        E_ERROR("uttproc_init called when not in UNDEF state\n");
        return -1;
    }

    fe = fe_init_auto();

    if (!fe)
        return -1;

    uttid = ckd_calloc(UTTIDSIZE, 1);

    if ((fn = cmd_ln_str("-hyp")) != NULL) {
        if ((matchfp = fopen(fn, "w")) == NULL)
            E_ERROR("fopen(%s,w) failed\n", fn);
    }
    if ((fn = cmd_ln_str("-hypseg")) != NULL) {
        if ((matchsegfp = fopen(fn, "w")) == NULL)
            E_ERROR("fopen(%s,w) failed\n", fn);
    }

    timing_init();

    uttstate = UTTSTATE_IDLE;
    utt_ofl = 0;
    uttno = 0;

    /* Initialize the FSG search module */
    {
        char *fsgfile;
        char *fsgname;
        char *fsgctlfile;
        FILE *ctlfp;
        char line[16384], word[16384];

        fsg_search = fsg_search_init(NULL);

        fsgfile = cmd_ln_str("-fsg");

        fsg_search_mode = (fsgfile != NULL);

        if (fsg_search_mode) {
            fsgname = uttproc_load_fsgfile(fsgfile);
            if (!fsgname)
                E_FATAL("Error loading FSG file '%s'\n", fsgfile);

            /* Make this FSG the currently active one */
            if (uttproc_set_fsg(fsgname) < 0)
                E_FATAL("Error setting current FSG to '%s'\n", fsgname);

            E_INFO
                ("FSG Mode; lextree, flat, bestpath searches disabled\n");
        }

        fsgctlfile = cmd_ln_str("-fsgctlfn");
        if (fsgctlfile) {
            if ((ctlfp = fopen(fsgctlfile, "r")) == NULL) {
                /* Should this be E_ERROR?? */
                E_FATAL("fopen(%s,r) failed\n", fsgctlfile);
            }

            while (fgets(line, sizeof(line), ctlfp) != NULL) {
                if ((line[0] == '#')    /* Commented out */
                    ||(sscanf(line, "%s", word) != 1))  /* Blank line */
                    continue;

                fsgfile = word;
                fsgname = uttproc_load_fsgfile(fsgfile);
                if (!fsgname) {
                    /* Should this be E_ERROR?? */
                    E_FATAL("Error loading FSG file '%s'\n", fsgfile);
                }
            }

            fclose(ctlfp);
        }
    }

    return 0;
}

/*
 * One time cleanup
 */
int32
uttproc_end(void)
{
    if (uttstate != UTTSTATE_IDLE) {
        E_ERROR("uttproc_end called when not in IDLE state\n");
        return -1;
    }

    if (matchfp)
        fclose(matchfp);
    if (matchsegfp)
        fclose(matchsegfp);

    timing_end();

    return 0;
}

int32
uttproc_begin_utt(char const *id)
{
    char filename[1024];
    int32 i;

    for (i = 0; i < 5; i++)
        samp_hist[i] = 0;
    max_samp = 0;

    if (uttstate != UTTSTATE_IDLE) {
        E_ERROR("uttproc_begin_utt called when not in IDLE state\n");
        return -1;
    }

    if (fe_start_utt(fe) < 0)
        return -1;

    inputtype = INPUT_UNKNOWN;

    livemode = !(nosearch ||
                 (fcb->cmn == CMN_CURRENT) ||
                 ((fcb->agc != AGC_EMAX) && (fcb->agc != AGC_NONE)));
    E_INFO("%s\n", livemode ? "Livemode" : "Batchmode");

    n_cepfr = n_featfr = n_searchfr = 0;
    utt_ofl = 0;

    uttno++;
    if (!id)
        sprintf(uttid, "%s%08d", uttid_prefix ? uttid_prefix : "", uttno);
    else
        strcpy(uttid, id);

    if (rawlogdir) {
        sprintf(filename, "%s/%s.raw", rawlogdir, uttid);
        if ((rawfp = fopen(filename, "wb")) == NULL)
            E_ERROR("fopen(%s,wb) failed\n", filename);
        else {
            strcpy(rawfilename, filename);
            E_INFO("Rawfile: %s\n", filename);
        }
    }
    if (mfclogdir) {
        int32 k = 0;

        sprintf(filename, "%s/%s.mfc", mfclogdir, uttid);
        if ((mfcfp = fopen(filename, "wb")) == NULL)
            E_ERROR("fopen(%s,wb) failed\n", filename);
        else
            fwrite(&k, sizeof(int32), 1, mfcfp);
    }

    timing_start();

    if (!nosearch) {
        if (fsg_search_mode)
            fsg_search_utt_start(fsg_search);
        else if (cmd_ln_boolean("-fwdtree"))
            search_start_fwd();
        else
            search_fwdflat_start();
    }

    uttstate = UTTSTATE_BEGUN;
    uttstart = TRUE;

    return 0;
}

int32
uttproc_rawdata(int16 * raw, int32 len, int32 block)
{
    int32 i, k, v, nfr;
    mfcc_t **temp_mfc;

    for (i = 0; i < len; i++) {
        v = raw[i];
        if (v < 0)
            v = -v;
        if (v > max_samp)
            max_samp = v;

        if (v < 4096)
            samp_hist[0]++;
        else if (v < 8192)
            samp_hist[1]++;
        else if (v < 16384)
            samp_hist[2]++;
        else if (v < 30720)
            samp_hist[3]++;
        else
            samp_hist[4]++;
    }

    if (uttstate != UTTSTATE_BEGUN) {
        E_ERROR("uttproc_rawdata called when utterance not begun\n");
        return -1;
    }
    if (inputtype == INPUT_MFC) {
        E_ERROR
            ("uttproc_rawdata mixed with uttproc_cepdata in same utterance??\n");
        return -1;
    }
    inputtype = INPUT_RAW;

    if (utt_ofl)
        return -1;

    k = (MAX_UTT_LEN - n_cepfr) * fe->FRAME_RATE;
    if (len > k) {
        len = k;
        utt_ofl = 1;
        E_ERROR("Utterance too long; truncating to about %d frames\n",
                MAX_UTT_LEN);
    }

    if (rawfp && (len > 0))
        fwrite(raw, sizeof(int16), len, rawfp);

    if ((k = fe_process_utt(fe, raw, len, &temp_mfc, &nfr)) < 0)
        return -1;
    if (nfr > 0)
        memcpy(mfcbuf[n_cepfr], temp_mfc[0], nfr * S2_CEP_VECLEN * sizeof(mfcc_t));

    if (mfcfp && (nfr > 0)) {
        fe_mfcc_to_float(fe, temp_mfc, (float32 **) temp_mfc, nfr);
        fwrite(temp_mfc[0], sizeof(float), nfr * S2_CEP_VECLEN, mfcfp);
    }
    fe_free_2d(temp_mfc);

    if (livemode) {
        nfr = feat_s2mfc2feat_block(fcb, mfcbuf + n_cepfr, nfr,
                                    uttstart, FALSE,
                                    feat_buf + n_featfr);
        uttstart = FALSE;
        n_cepfr += nfr;
        n_featfr += nfr;

        if (n_searchfr < n_featfr)
            uttproc_frame();

        if (block) {
            while (n_searchfr < n_featfr)
                uttproc_frame();
        }
    }
    else
        n_cepfr += nfr;

    return (n_featfr - n_searchfr);
}

int32
uttproc_cepdata(float32 ** cep, int32 nfr, int32 block)
{
    int32 i, k;

    if (uttstate != UTTSTATE_BEGUN) {
        E_ERROR("uttproc_cepdata called when utterance not begun\n");
        return -1;
    }
    if (inputtype == INPUT_RAW) {
        E_ERROR
            ("uttproc_cepdata mixed with uttproc_rawdata in same utterance??\n");
        return -1;
    }
    inputtype = INPUT_MFC;

    if (utt_ofl)
        return -1;

    k = MAX_UTT_LEN - n_cepfr;
    if (nfr > k) {
        nfr = k;
        utt_ofl = 1;
        E_ERROR("Utterance too long; truncating to about %d frames\n",
                MAX_UTT_LEN);
    }

    for (i = 0; i < nfr; i++) {
#ifdef FIXED_POINT
        int j;
        for (j = 0; j < S2_CEP_VECLEN; ++j)
            mfcbuf[n_cepfr + i][j] = FLOAT2FIX(cep[i][j]);
#else
        memcpy(mfcbuf[i + n_cepfr], cep[i], S2_CEP_VECLEN * sizeof(float));
#endif
        if (mfcfp && (nfr > 0))
            fwrite(cep[i], sizeof(float32), S2_CEP_VECLEN, mfcfp);
    }

    if (livemode) {
        nfr = feat_s2mfc2feat_block(fcb, mfcbuf + n_cepfr, nfr,
                                    uttstart, FALSE,
                                    feat_buf + n_featfr);
        uttstart = FALSE;
        n_cepfr += nfr;
        n_featfr += nfr;

        if (n_searchfr < n_featfr)
            uttproc_frame();

        if (block) {
            while (n_searchfr < n_featfr)
                uttproc_frame();
        }
    }
    else
        n_cepfr += nfr;

    return (n_featfr - n_searchfr);
}

int32
uttproc_end_utt(void)
{
    int32 i, k, nfr;
    mfcc_t *leftover_cep;

    /* kal */
    leftover_cep = ckd_calloc(S2_CEP_VECLEN, sizeof(mfcc_t));

    /* Dump samples histogram */
    k = 0;
    for (i = 0; i < 5; i++)
        k += samp_hist[i];
    if (k > 0) {
        E_INFO("Samples histogram (%s) (4/8/16/30/32K):",
               uttproc_get_uttid());
        for (i = 0; i < 5; i++)
            E_INFOCONT(" %.1f%%(%d)", samp_hist[i] * 100.0 / k,
                       samp_hist[i]);
        E_INFOCONT("; max: %d\n", max_samp);
    }

    if (uttstate != UTTSTATE_BEGUN) {
        E_ERROR("uttproc_end_utt called when utterance not begun\n");
        return -1;
    }

    uttstate = nosearch ? UTTSTATE_IDLE : UTTSTATE_ENDED;

    if (inputtype == INPUT_RAW) {
        fe_end_utt(fe, leftover_cep, &nfr);
        if (nfr && mfcfp) {
            fe_mfcc_to_float(fe, &leftover_cep, &leftover_cep, nfr);
            fwrite(leftover_cep, sizeof(float32), nfr * S2_CEP_VECLEN, mfcfp);
        }

        if (livemode) {
            nfr = feat_s2mfc2feat_block(fcb, &leftover_cep, nfr,
                                        uttstart, TRUE,
                                        feat_buf + n_featfr);
            uttstart = FALSE;
            n_featfr += nfr;
        }
        else {
            if (nfr) {
                memcpy(mfcbuf[i + n_cepfr], leftover_cep,
                       nfr * S2_CEP_VECLEN * sizeof(float));
                n_cepfr += nfr;
            }
        }
    }

    /* Do feature computation if not in livemode. */
    if (!livemode) {
        /* If we had file input, n_cepfr will be zero. */
        if (n_cepfr) {
            nfr = feat_s2mfc2feat_block(fcb, mfcbuf, n_cepfr,
                                        TRUE, TRUE, feat_buf);
            n_featfr += nfr;
        }
    }

    /* Do any further searching necessary. */
    if (!nosearch) {
        while (n_searchfr < n_featfr)
            uttproc_frame();
    }

    if (rawfp) {
        fclose(rawfp);
        rawfp = NULL;
    }
    if (mfcfp) {
        int32 k;

        fflush(mfcfp);
        fseek(mfcfp, 0, SEEK_SET);
        k = n_cepfr * S2_CEP_VECLEN;
        fwrite(&k, sizeof(int32), 1, mfcfp);

        fclose(mfcfp);
        mfcfp = NULL;
    }

    free(leftover_cep);

    return 0;
}

int32
uttproc_abort_utt(void)
{
    int32 fr;
    char *hyp;

    if (uttproc_end_utt() < 0)
        return -1;

    /* Truncate utterance to the portion already processed */
    n_featfr = n_searchfr;

    uttstate = UTTSTATE_IDLE;

    if (!nosearch) {
        if (fsg_search_mode)
            fsg_search_utt_end(fsg_search);
        else {
            if (cmd_ln_boolean("-fwdtree"))
                search_finish_fwd();
            else
                search_fwdflat_finish();

            search_result(&fr, &hyp);

            write_results(hyp, 1);
        }
        timing_stop(fr);
    }

    return 0;
}

int32
uttproc_stop_utt(void)
{
    if (uttstate != UTTSTATE_BEGUN) {
        E_ERROR("uttproc_stop_utt called when utterance not begun\n");
        return -1;
    }

    uttstate = UTTSTATE_STOPPED;

    if (!nosearch) {
        if (fsg_search_mode)
            fsg_search_utt_end(fsg_search);
        else {
            if (cmd_ln_boolean("-fwdtree"))
                search_finish_fwd();
            else
                search_fwdflat_finish();
        }
    }

    return 0;
}

int32
uttproc_restart_utt(void)
{
    if (uttstate != UTTSTATE_STOPPED) {
        E_ERROR("uttproc_restart_utt called when decoding not stopped\n");
        return -1;
    }

    uttstate = UTTSTATE_BEGUN;

    if (!nosearch) {
        if (fsg_search_mode)
            fsg_search_utt_start(fsg_search);
        else if (cmd_ln_boolean("-fwdtree"))
            search_start_fwd();
        else
            search_fwdflat_start();

        n_searchfr = 0;
        n_searchfr = 0;
    }

    return 0;
}

int32
uttproc_partial_result(int32 * fr, char **hyp)
{
    if ((uttstate != UTTSTATE_BEGUN) && (uttstate != UTTSTATE_ENDED)) {
        E_ERROR("uttproc_partial_result called outside utterance\n");
        *fr = -1;
        *hyp = NULL;
        return -1;
    }

    if (fsg_search_mode) {
        fsg_search_history_backtrace(fsg_search, FALSE);
        search_result(fr, hyp);
    }
    else
        search_partial_result(fr, hyp);

    return 0;
}

int32
uttproc_result(int32 * fr, char **hyp, int32 block)
{
    if (uttstate != UTTSTATE_ENDED) {
        E_ERROR("uttproc_result called when utterance not ended\n");
        *hyp = NULL;
        *fr = -1;

        return -1;
    }

    if (n_searchfr < n_featfr)
        uttproc_frame();

    if (block) {
        while (n_searchfr < n_featfr)
            uttproc_frame();
    }

    if (n_searchfr < n_featfr)
        return (n_featfr - n_searchfr);

    uttproc_windup(fr, hyp);

    return 0;
}

void
uttproc_align(char *sent)
{
    time_align_utterance("alignment", NULL, "<s>", -1, sent, -1, "</s>");
}

void
utt_seghyp_free(search_hyp_t * h)
{
    search_hyp_t *tmp;

    while (h) {
        tmp = h->next;
        listelem_free(h, sizeof(search_hyp_t));
        h = tmp;
    }
}

static void
build_utt_seghyp(void)
{
    int32 i;
    search_hyp_t *seghyp, *last, *new;

    /* Obtain word segmentation result */
    seghyp = search_get_hyp();

    /* Fill in missing details and build segmentation linked list */
    last = NULL;
    for (i = 0; seghyp[i].wid >= 0; i++) {
        new = (search_hyp_t *) listelem_alloc(sizeof(search_hyp_t));
        new->wid = seghyp[i].wid;
        new->word = kb_get_word_str(new->wid);
        new->sf = seghyp[i].sf;
        new->ef = seghyp[i].ef;
        new->latden = seghyp[i].latden;
        new->next = NULL;

        if (!last)
            utt_seghyp = new;
        else
            last->next = new;
        last = new;
    }
}

int32
uttproc_partial_result_seg(int32 * fr, search_hyp_t ** hyp)
{
    char *str;

    /* Free any previous segmentation result */
    utt_seghyp_free(utt_seghyp);
    utt_seghyp = NULL;

    if ((uttstate != UTTSTATE_BEGUN) && (uttstate != UTTSTATE_ENDED)) {
        E_ERROR("uttproc_partial_result called outside utterance\n");
        *fr = -1;
        *hyp = NULL;
        return -1;
    }

    if (fsg_search_mode) {
        fsg_search_history_backtrace(fsg_search, FALSE);
        search_result(fr, &str);
    }
    else
        search_partial_result(fr, &str);        /* Internally makes partial result */

    build_utt_seghyp();
    *hyp = utt_seghyp;

    return 0;
}

int32
uttproc_result_seg(int32 * fr, search_hyp_t ** hyp, int32 block)
{
    char *str;
    int32 res;

    /* Free any previous segmentation result */
    utt_seghyp_free(utt_seghyp);
    utt_seghyp = NULL;

    if ((res = uttproc_result(fr, &str, block)) != 0)
        return res;             /* Not done yet; or ERROR */

    build_utt_seghyp();
    *hyp = utt_seghyp;

    return 0;
}

int32
uttproc_lmupdate(char const *lmname)
{
    lm_t *lm, *cur_lm;

    warn_notidle("uttproc_lmupdate");

    if ((lm = lm_name2lm(lmname)) == NULL)
        return -1;

    cur_lm = lm_get_current();
    if (lm == cur_lm)
        search_set_current_lm();

    return 0;
}

int32
uttproc_set_context(char const *wd1, char const *wd2)
{
    int32 w1, w2;

    warn_notidle("uttproc_set_context");

    if (wd1) {
        w1 = kb_get_word_id(wd1);
        if ((w1 < 0) || (!dictwd_in_lm(w1))) {
            E_ERROR("Unknown word: %s\n", wd1);
            search_set_context(-1, -1);

            return -1;
        }
    }
    else
        w1 = -1;

    if (wd2) {
        w2 = kb_get_word_id(wd2);
        if ((w2 < 0) || (!dictwd_in_lm(w2))) {
            E_ERROR("Unknown word: %s\n", wd2);
            search_set_context(-1, -1);

            return -1;
        }
    }
    else
        w2 = -1;

    if (w2 < 0) {
        search_set_context(-1, -1);
        return ((w1 >= 0) ? -1 : 0);
    }
    else {
        /* Because of the perverse way search_set_context was defined... */
        if (w1 < 0)
            search_set_context(w2, -1);
        else
            search_set_context(w1, w2);
    }

    return 0;
}

int32
uttproc_set_lm(char const *lmname)
{
    warn_notidle("uttproc_set_lm");

    if (lmname == NULL) {
        E_ERROR("uttproc_set_lm called with NULL argument\n");
        return -1;
    }

    if (lm_set_current(lmname) < 0)
        return -1;

    fsg_search_mode = FALSE;

    search_set_current_lm();

    E_INFO("LM= \"%s\"\n", lmname);

    return 0;
}


int32
uttproc_load_fsg(s2_fsg_t * fsg,
                 int32 use_altpron,
                 int32 use_filler,
                 float32 silprob, float32 fillprob, float32 lw)
{
    word_fsg_t *word_fsg;

    word_fsg =
        word_fsg_load(fsg, use_altpron, use_filler, silprob, fillprob, lw);

    if (!word_fsg)
        return 0;

    if (!fsg_search_add_fsg(fsg_search, word_fsg)) {
        E_ERROR("Failed to add FSG '%s' to system\n",
                word_fsg_name(word_fsg));
        word_fsg_free(word_fsg);
        return 0;
    }

    return 1;
}


char *
uttproc_load_fsgfile(char *fsgfile)
{
    word_fsg_t *fsg;

    fsg = word_fsg_readfile(fsgfile,
                            cmd_ln_boolean("-fsgusealtpron"),
                            cmd_ln_boolean("-fsgusefiller"),
                            cmd_ln_float32("-silpen"),
                            cmd_ln_float32("-fillpen"),
                            cmd_ln_float32("-lw"));
    if (!fsg)
        return NULL;

    if (!fsg_search_add_fsg(fsg_search, fsg)) {
        E_ERROR("Failed to add FSG '%s' to system\n", word_fsg_name(fsg));
        word_fsg_free(fsg);
        return NULL;
    }

    return fsg->name;
}


int32
uttproc_del_fsg(char *fsgname)
{
    warn_notidle("uttproc_del_fsg");

    if (fsgname == NULL) {
        E_ERROR("uttproc_del_fsg called with NULL argument\n");
        return -1;
    }

    if (!fsg_search_del_fsg_byname(fsg_search, fsgname))
        return -1;

    return 0;
}


int32
uttproc_set_fsg(char *fsgname)
{
    warn_notidle("uttproc_set_fsg");

    if (fsgname == NULL) {
        E_ERROR("uttproc_set_fsg called with NULL argument\n");
        return -1;
    }

    if (!fsg_search_set_current_fsg(fsg_search, fsgname))
        return -1;

    fsg_search_mode = TRUE;

    E_INFO("FSG= \"%s\"\n", fsgname);

    return 0;
}



int32
uttproc_get_fsg_start_state(void)
{
    return fsg_search_get_start_state(fsg_search);
}


int32
uttproc_get_fsg_final_state(void)
{
    return fsg_search_get_final_state(fsg_search);
}


int32
uttproc_set_fsg_start_state(int32 state)
{
    return fsg_search_set_start_state(fsg_search, state);
}


int32
uttproc_set_fsg_final_state(int32 state)
{
    return fsg_search_set_final_state(fsg_search, state);
}


boolean
uttproc_fsg_search_mode(void)
{
    return fsg_search_mode;
}


int32
uttproc_set_rescore_lm(char const *lmname)
{
    searchlat_set_rescore_lm(lmname);
    return 0;
}

int32
uttproc_set_startword(char const *str)
{
    warn_notidle("uttproc_set_startword");

    search_set_startword(str);
    return 0;
}

void
uttproc_set_feat(feat_t *new_fcb)
{
    warn_notidle("uttproc_set_feat");

    if (fcb)
        feat_free(fcb);
    fcb = new_fcb;
    feat_alloc();
}

#if 0
int32
uttproc_set_uttid(char const *id)
{
    warn_notidle("uttproc_set_uttid");

    assert(strlen(id) < UTTIDSIZE);
    strcpy(uttid, id);

    return 0;
}
#endif

char const *
uttproc_get_uttid(void)
{
    return uttid;
}

int32
uttproc_set_auto_uttid_prefix(char const *prefix)
{
    if (uttid_prefix)
        free(uttid_prefix);
    uttid_prefix = ckd_salloc(prefix);
    uttno = 0;

    return 0;
}

void
uttproc_cepmean_set(mfcc_t * cep)
{
    warn_notidle("uttproc_cepmean_set");
    cmn_prior_set(fcb->cmn_struct, cep);
}

void
uttproc_cepmean_get(mfcc_t * cep)
{
    cmn_prior_get(fcb->cmn_struct, cep);
}

void
uttproc_agcemax_set(float32 c0max)
{
    warn_notidle("uttproc_agcemax_set");
    agc_emax_set(fcb->agc_struct, c0max);
}

float32
uttproc_agcemax_get(void)
{
    return agc_emax_get(fcb->agc_struct);
}

int32
uttproc_nosearch(int32 flag)
{
    warn_notidle("uttproc_nosearch");

    nosearch = flag;
    return 0;
}

int32
uttproc_set_rawlogdir(char const *dir)
{
    warn_notidle("uttproc_set_rawlogdir");

    if (!rawlogdir) {
        if ((rawlogdir = calloc(1024, 1)) == NULL) {
            E_ERROR("calloc(1024,1) failed\n");
            return -1;
        }
    }
    if (rawlogdir)
        strcpy(rawlogdir, dir);

    return 0;
}

int32
uttproc_set_mfclogdir(char const *dir)
{
    warn_notidle("uttproc_set_mfclogdir");

    if (!mfclogdir) {
        if ((mfclogdir = calloc(1024, 1)) == NULL) {
            E_ERROR("calloc(1024,1) failed\n");
            return -1;
        }
    }
    if (mfclogdir)
        strcpy(mfclogdir, dir);

    return 0;
}

int32
uttproc_parse_ctlfile_entry(char *line,
                            char *filename, int32 * sf, int32 * ef,
                            char *idspec)
{
    int32 k;

    /* Default; process entire file */
    *sf = 0;
    *ef = -1;

    if ((k = sscanf(line, "%s %d %d %s", filename, sf, ef, idspec)) <= 0)
        return -1;

    if (k == 1)
        strcpy(idspec, filename);
    else {
        if ((k == 2) || (*sf < 0) || (*ef <= *sf)) {
            E_ERROR("Bad ctlfile entry: %s\n", line);
            return -1;
        }
        if (k == 3)
            sprintf(idspec, "%s_%d_%d", filename, *sf, *ef);
    }

    return 0;
}

/* Return #frames converted to feature vectors; -1 if error */
int32
uttproc_file2feat(const char *utt, int32 sf, int32 ef, int32 nosearch)
{
    FILE *uttfp;
    char *utt_name;

    utt_name = build_uttid(utt);

    if (cmd_ln_boolean("-adcin")) {
        int16 *adbuf;
        int32 k;

        inputtype = INPUT_RAW;
        if ((uttfp = adcfile_open(utt)) == NULL)
            return -1;

        if (uttproc_nosearch(nosearch) < 0)
            return -1;

        if (uttproc_begin_utt(utt_name) < 0)
            return -1;

        adbuf = ckd_calloc(4096, sizeof(int16));
        while ((k = adc_file_read(uttfp, adbuf, 4096)) >= 0) {
            if (uttproc_rawdata(adbuf, k, 1) < 0) {
                ckd_free(adbuf);
                return -1;
            }
        }
        ckd_free(adbuf);

        if (uttproc_end_utt() < 0)
            return -1;

        return n_featfr;
    }
    else {
        if (uttproc_nosearch(nosearch) < 0)
            return -1;

        if (uttproc_begin_utt(utt_name) < 0)
            return -1;

        n_cepfr = 0;
        n_featfr = feat_s2mfc2feat(fcb, utt,
                                   cmd_ln_str("-cepdir"),
                                   cmd_ln_str("-cepext"),
                                   sf, ef, feat_buf, MAX_UTT_LEN);

        if (nosearch == FALSE) {
            while (n_searchfr < n_featfr)
                uttproc_frame();
        }

        if (uttproc_end_utt() < 0)
            return -1;

        return n_featfr;
    }
}

search_hyp_t *
uttproc_allphone_file(char const *utt)
{
    int32 nfr;
    search_hyp_t *hyplist, *h;
    extern search_hyp_t * allphone_utt(int32 nfr, mfcc_t ***feat_buf);

    if ((nfr = uttproc_file2feat(utt, 0, -1, 1)) < 0)
        return NULL;

    hyplist = allphone_utt(nfr, feat_buf);

    /* Write match and matchseg files if needed */
    if (matchfp) {
        for (h = hyplist; h; h = h->next)
            fprintf(matchfp, "%s ", h->word);
        fprintf(matchfp, "(%s)\n", uttid);
        fflush(matchfp);
    }
    if (matchsegfp) {
        fprintf(matchsegfp, "%s ", uttid);
        for (h = hyplist; h; h = h->next)
            fprintf(matchsegfp, " %d %d %s", h->sf, h->ef, h->word);
        fprintf(matchsegfp, "\n");
        fflush(matchsegfp);
    }

    return hyplist;
}

static FILE *logfp;
static char logfile[MAXPATHLEN]; /* FIXME buffer */
int32
uttproc_set_logfile(char const *file)
{
    FILE *fp;

    E_INFO("uttproc_set_logfile(%s)\n", file);

    if ((fp = fopen(file, "w")) == NULL) {
        E_ERROR("fopen(%s,w) failed; logfile unchanged\n", file);
        return -1;
    }
    else {
        if (logfp)
            fclose(logfp);

        logfp = fp;
        /* 
         * Rolled back the dup2() bug fix for windows only. In
         * Microsoft Visual C, dup2 seems to cause problems in some
         * applications: the files are opened, but nothing is written
         * to it.
         */
#if defined(_WIN32)
#ifndef _WIN32_WCE /* FIXME: Possible? */
        *stdout = *logfp;
        *stderr = *logfp;
#endif
#else
        dup2(fileno(logfp), 1);
        dup2(fileno(logfp), 2);
#endif

        E_INFO("Previous logfile: '%s'\n", logfile);
        strcpy(logfile, file);
    }

    return 0;
}
